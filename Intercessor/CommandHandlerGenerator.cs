using Intercessor.Abstractions;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Intercessor;

/// <summary>
/// A source generator that automatically creates request handlers for Intercessor IRequest implementations.
/// </summary>
[Generator]
public class CommandHandlerGenerator : IIncrementalGenerator
{
    /// <summary>
    /// Initializes the incremental source generator by registering a syntax provider that scans for types
    /// implementing the <c>IRequest&lt;TResponse&gt;</c> interface from Intercessor. When such types are found,
    /// this generator produces corresponding <c>IRequestHandler&lt;TRequest, TResponse&gt;</c> implementations
    /// as compile-time-generated C# classes.
    /// </summary>
    /// <param name="context">The initialization context provided by the Roslyn compiler.</param>
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var requestCandidates = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (s, _) => s is ClassDeclarationSyntax { BaseList: not null },
                transform: static (ctx, _) => GetSemanticTarget(ctx))
            .Where(static t => t is not null);

        var compilationAndRequests = context.CompilationProvider.Combine(requestCandidates.Collect());
        
        context.RegisterSourceOutput(compilationAndRequests, static (spc, source) =>
        {
            var (compilation, requests) = source;

            foreach (var req in requests.Distinct())
            {
                if (req?.SyntaxTree == null) continue;

                var semanticModel = compilation.GetSemanticModel(req.SyntaxTree);

                if (semanticModel.GetDeclaredSymbol(req) is not INamedTypeSymbol symbol) continue;

                var requestName = symbol.Name;
                var responseType = GetResponseType(symbol);

                var handlerName = $"{requestName}Handler";
                var ns = symbol.ContainingNamespace.ToDisplayString();

                if (compilation.GetTypeByMetadataName($"{ns}.{handlerName}") is null)
                {
                    if (string.IsNullOrWhiteSpace(responseType))
                    {
                        GenerateCommandHandlerWithResponseTypeTemplate(ns, handlerName, requestName, spc);
                    }
                    else
                    {
                        GenerateCommandHandlerWithNoResponseTypeTemplate(ns, handlerName, requestName, responseType, spc);
                    }   
                }

                if (compilation.GetTypeByMetadataName($"{ns}.{requestName}") is not null) continue;

                GenerateFluentValidationRulesTemplate(ns, requestName, spc);
            }
        });
    }
    private static void GenerateCommandHandlerWithResponseTypeTemplate(string ns, string handlerName, string requestName, SourceProductionContext spc)
    {
        var code = $$"""
                     // <auto-generated />
                     using System.Threading;
                     using System.Threading.Tasks;
                     using Intercessor.Abstractions;

                     namespace {{ns}};

                     public sealed class {{handlerName}} : ICommandHandler<{{requestName}}>
                     {
                         public Task HandleAsync({{requestName}} request, CancellationToken cancellationToken = default)
                         {
                             // TODO: Implement logic
                             throw new NotImplementedException();
                         }
                     }
                     """;

        spc.AddSource($"{handlerName}.cs", code);
    }
    private static void GenerateCommandHandlerWithNoResponseTypeTemplate(string ns, string handlerName, string requestName, string responseType,
        SourceProductionContext spc)
    {
        var code = $$"""
                     // <auto-generated />
                     using System.Threading;
                     using System.Threading.Tasks;
                     using Intercessor.Abstractions;

                     namespace {{ns}};

                     public sealed class {{handlerName}} : ICommandHandler<{{requestName}}, {{responseType}}>
                     {
                         public Task<{{responseType}}> HandleAsync({{requestName}} request, CancellationToken cancellationToken = default)
                         {
                             // TODO: Implement logic
                             throw new NotImplementedException();
                         }
                     }
                     """;

        spc.AddSource($"{handlerName}.cs", code);
    }
    private static void GenerateFluentValidationRulesTemplate(string ns, string requestName, SourceProductionContext spc)
    {
        var fluentValidationRules = $$"""
                                      // <auto-generated />
                                      using System.Threading;
                                      using System.Threading.Tasks;
                                      using Intercessor.Abstractions;
                                      using FluentValidation;

                                      namespace {{ns}};

                                      public class {{requestName}}Validator: AbstractValidator<{{requestName}}>
                                      {
                                          public {{requestName}}Validator()
                                          {
                                          }
                                      }
                                      """;

        spc.AddSource($"{requestName}Validator.cs", fluentValidationRules);
    }

    private static ClassDeclarationSyntax? GetSemanticTarget(GeneratorSyntaxContext context)
    {
        var classDecl = (ClassDeclarationSyntax)context.Node;

        var symbol = context.SemanticModel.GetDeclaredSymbol(classDecl);
        if (symbol is not INamedTypeSymbol classSymbol)
            return null;

        var implementsIRequest = classSymbol.AllInterfaces
            .Any(i =>
                i.Name == nameof(ICommand) &&
                i.ContainingNamespace.ToDisplayString().StartsWith(nameof(Intercessor)));

        return implementsIRequest ? classDecl : null;
    }

    private static string? GetResponseType(INamedTypeSymbol symbol)
    {
        var requestInterface = symbol.AllInterfaces.First(i =>
            i is { Name: nameof(ICommand), TypeArguments.Length: 0 or 1 });

        var hasResponse = requestInterface.TypeArguments.Length > 0;
        return hasResponse ? requestInterface.TypeArguments[0].ToDisplayString() : null;
    }
}